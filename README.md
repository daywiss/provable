# Provable
A Provably random engine which can be plugged into [random-js](https://www.npmjs.com/package/random-js). 

#Install
`npm install --save provable`

#About
This library attempts to implement the algorithm first outlined in the bitcoin talk formums:
[https://bitcointalk.org/index.php?topic=922898.0](https://bitcointalk.org/index.php?topic=922898.0).
The idea behind provably random is that a deteministic series of related but random hashes are generated before
any random outcomes are calculated. Once generated, each hash in the series is used to create a random outcome.
The provable part comes in when a client wants to verify the integrity of the outcome. After every outcome
is produced the hash which produced it can also be made public. If one has access to the current hash and
the previous hash (from the previous outcome), then a SHA256 can be used on the current hash to generate the previous.
This should hold true for all hashes in the series as they are exposed. You cannot predict the next hash, but you
can verify the previous hash by hashing its predecessor. Any deviation from this verification result would mean that the hashes
were tampered with  and not part of the pregenerated series. Hence you can "prove" the random outcome was fair.

#Usage
This library can be used standalone to generate a series of random hashes generated by nodes crypto sha256 hasher. The engine can then
be plugged into random-js in order to give you more control over your random values. By default
the engine will only supply a 32-bit random integer based on the next hash in the series. The 
state of the engine can be saved and resumed as needed.

```js
  var Provable = require('provable')

  var engine = Provable({
    count:10000, //default:1, number of hashes in the series to produce, takes longer depending on how big the number is
    seed:'optional seed to start your series with' //defaults to a random uuid4
  })

  //return a random int32
  var int32 = engine()

  //raw sha256 hash. Increments your hash index. Throws an error if no hashes left.
  //if you want to do your own random calculations then use this. 
  var hash = engine.nextHash()

  //internal state of the engine. Use this to save and resume your engine.
  var state = engine.state()

  //resuming will re-generate the entire hash chain from your seed and pick up where you
  //left off with the index
  var resumedEngine = Provable(state)

```

#Random-JS
[Random-js](https://www.npmjs.com/package/random-js) can give you more control over the values you can get. Keep in mind that random-js
only uses 32 bits of the hash, the rest is discarded. This provable engine defaults to using the 32 least
significant bits of the hash when generating the random integer.

```js
  var Random = require('random-js')
  var Engine = require('provable')

  //use random like a random-js object
  var random = Random(Engine({ count:10000 })

  //some examples
  random.bool()
  random.integer(min,max)
  random.real(min,max,inclusive)
  //etc...

  //keep in mind, the provable engine will throw when out of values, so you should wrap 
  //each call in try catch. When the engine throws, you should start a new serie When the engine throws, you should start a new series. 


```

#API
##Construction
The provable engine has an internal state which you can pass in as the only argument to construction. By default
no parameters are needed, but its suggested you change at least the count argument to something large. This
will specify the number of calls you can make to get hashes before the engine errors.
Hashes are generated on instance construction and are generated sycnronously so long hash counts
may cause blocking. You can forgo seeding the engine, a random UUIDv4 will be generated as the seed.

```js
  var Provable = require('provable')
  //node the actual list of hashes is not passed in as option. This will be generated on engine construction
  //based on the config you supply. You can get the list with engine.hashes()

  var config = {
    id: // a string representing the unique id of this hash series
    index: // integer representing which hash in the series will be used next
    count: //the number of hashes in this series
    seed: //a string to seed nodes crypto engine to start generating the first hash (last hash of series). Withold to seed with random hash.
    clientSeed: //an additional seed value supplied, will update the hash before being returned from nextHash()
    onChange: //a function callback which returns the state of the engine after every change. Optionally poll state instead with engine.state()
  }

  var engine = Provable(config)
  //do stuff..
```

##engine() 
The default function of the engine is to provide a random 32 bit integer. This allows random-js to wrap the engine
and produce random primitives. The integer is based on sampling the least significant 32 bits of the current hash.

```js
  //integer is random between [0, 2^32] inclusive
  //this increments your hash index and will call the change callback
  var integer = engine()
```

##nextHash()
This gets the next raw hash in the series and increments your hash index. Will throw an error if no more hashes are found.
If hashes run out, then generate a new engine with a new seed. Do not reuse old seeds as you will generate predictable
hashes.

```js
  //the next raw sha256 hash in the series. Update hash index and throws if no more hashes found.
  var hash = engine.nextHash()
```

##peekHash()
Peek at the next hash without changing engine state. Returns undefined if no hashes are found.
```js
  //the next raw sha256 hash in the series, does not change state of engine. 
  var hash = engine.peekHash()
```

##getHash(index)
Get the hash at specified index. Does not update engine, allows you read access to your hash chain.
```js
  //get hash at specific location in hash series. Series starts with hash 0 and ends with hash count-1.
  //your engine state will show your current position with engine.state().index
  var hash = engine.getHash(100)
```

##generate(count,seed)
Generate a raw hash series. This is used internally by the engine but is exposed in case its useful
to use directly. Consider it like a static function, does not reference the internal state of the 
engine. The result is an array of hashes which should be used starting at series[0]. Its important
to use the hashes in the correct order, or they will be predictable.
```js
  //generate 10000 hashes and returns an array of them with the seed value of "seed"
  var series = engine.generate(10000,'seed')
```






